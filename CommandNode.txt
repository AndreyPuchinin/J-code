from abc import ABC, abstractmethod

class CommandNode(ABC):
    def __init__(self, name, value_type, action, line, char_pos, command_path):
        self._name = name  # Имя команды (ключ в JSON)
        self._value_type = value_type  # Ожидаемый тип значения (list, dict, int, str и т.д.)
        self._action = action  # Значение команды (то, что после ":")
        self._line = line  # Номер строки
        self._char_pos = char_pos  # Позиция символа
        self._command_path = command_path  # Путь к команде
        self._errors = []  # Список для хранения ошибок

    @abstractmethod
    def Errors(self):
        """Абстрактный метод для проверки ошибок. Должен быть реализован в наследниках."""
        pass

    def get_cmd_path(self):
        return self._command_path

    def get_line(self):
        return self._line

    def get_char_pos(self):
        return self._char_pos

    def _log_error(self, message):
        """Логирование ошибки с указанием места в коде."""
        if self._line == None:
            self._line = "<не найдена>"
        if self._char_pos == None:
            self._char_pos = "<не найдена>"
        error_message = f"Ошибка в файле '{self._name}' по пути {self._command_path._get_path()} (строка = {self._line}, позиция = {self._char_pos}): {message}"
        self._errors.append(error_message)

    def _type_check(self):
        """Проверка, соответствует ли тип значения ожидаемому."""
        if not isinstance(self._action, self._value_type):
            self._log_error(f"Ожидался тип команды {self._name} = {self._value_type}, получен {type(self._action)}.")
            return False
        return True

    def get_errors(self):
        """Возвращает список ошибок."""
        return self._errors