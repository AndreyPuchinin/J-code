CommandNode. Должен:
-иметь и определять поля
--name (подтягивается из кода)
--type (определяется из параметров команды)
--params (подтягивается из кода)
--inner_cmds (подтягивается из кода)
--path (определяется из кода)
--line (определяется из кода)
--char_pos (определяется из кода)


Линковщик должен:

0.Удалить все символы из каждой строки после первого "#" (комментарии)

1.Определить синтаксические ошибки:

-Синтаксические проверки джейсона. Релизнуть отдельный, не встроенный в Питон механизм, т.к. встроенный дает лишь первую ошибку! Релиз этого механизма может использовать технологии ниже

2.Дерево команд (cmd_path), заполняет все поля CommandNode для каждой команды

3.Доопределение синтаксических ошибкок:

-Несоответствие заявленных типов полей CommandNode'а для текущей команды при её определении и их реальных значений для неё же из контекста её применения в конкретном месте кода

4.Дерево инклюдов:

4.1 Проверка существования подключаемых файлов
4.2 Проверка нецикличности инклюдов

5.Проверка каждого подключаемого файла на условия выше (1-3)

6.Линковка всех файлов в 1


ИСПОЛНИТЕЛЬ:

7.Семантические ошибки (выход за рамки статических массивов, другие переполнения статической памяти, например, переменные)

8.Ошибки при исполнении (выход за рамки динамических массивов, переполнение стека рекурсии, None Type of current command, ...)


КОМАНДЫ (Необходимо свести к минимуму количество Изначальных атомарных команд, максимально повысив их эффективность, чтобы можно было ввести такие команды как for и if с помощью них):

-include
-new_type
-cmd_type
-new_cmd
-cmd_param
-count

1.include. Синтаксис:

{"include": <path to file.json>} # подключаем <path to file.json>
или
{"include": {"include": <path to file.json>}} # подключаем содержимое файлов по их именам из <path to file.json>
или
... # более глубокие подключения

# Все это следует зашить не в Ядро J-CODE, а в его системную настройку на нем самом, сведя количество системных команд, готовых к релизу на Ядре, к минимуму


2.New_type. Синтаксис:

{
  "new_type": 
  {
    "type_name": 
      [ "<type1>", "<type2>", "...", ... ] #<type> может быть как системным, так и пользовательским
      # зпт между типами = or (например, str or list or None)
  }
}


3.Cmd_type. Синтаксис:

{"cmd_type": "<cmd>"} # Вернет тип <cmd>, если <cmd> определена ранее, иначе - None


4.New_cmd. Синтаксис:

{
  "new_cmd": {
    "name": "<cmd_name>",
    "params_names&types": # ДОЛЖЕН БЫТЬ ХОТЯ БЫ 1 ПАРАМЕТР
    [
      {"<param_name1>": [<types>]},
      {"<param_name2>": [<types>]},
      ...
    ]
    "inner_cmds": # можно пропустить этот параметр
    [
      ...
    ]
  }
}

# Чтобы изменить УЖЕ заданную функцию, нужно изменить её ПЕРВОЕ определение (все повторные вызовут ошибку на этапе Линковки)


5.Cmd_param. Синтаксис:

{
  "cmd_param": 
  {
    "cmd_name": "<cmd_name>",
    "cmd_param": <cmd_param>,
    "param_depth": <int>
  }
}

# Вернет значение параметра команды, выныривая от более локальной области видимости (перескакивая "cmd_param") к более глобальной, и останавливаясь не выше, чем на уровне <int>. (Если, например, всего 2 уровня видимости, а передано 3 - вернет тот, что на уровне 2).

# Уровень 0 при этом соответсвтует текущей области видимости


6.Count. Синтаксис:

{
  "count": ["<int>", <operation>, <int>]
}

или

{
  "count": ["<int>", <operation>, {"count": ...}]
}

# Может подключать функции изнутри Ядра Питона, но только с проверкой (чтобы нельзя было что-то вроде {"count": "format c:"})