Допиши ComandPath.get_line_and_pos() последовательно по моему ТЗ, которое я буду постепенно усложнять:

1.Определи изнутри ComandPath.get_line_and_pos() текущую команду и выведи её на экран. Сейчас это может быть одна из трех зерезервированных команд:

1.1 UnknownCommand
1.2 include
1.3 game_field

================

Нет, мне не нужно проверять команды руками, я хочу, чтобы их можно было добавлять в резерв и подтягивать оттуда для проверки. Этот резерв уже есть, например, в LinkerAndSyntaxChecker

================

Сейчас вывод программы:

Текущая команда:  (неизвестная)
Текущая команда:  (неизвестная)
Текущая команда:  (неизвестная)
Текущая команда:  (неизвестная)
Текущая команда:  (неизвестная)
Текущая команда:  (неизвестная)
Текущая команда:  (неизвестная)
Текущая команда:  (неизвестная)
Текущая команда:  (неизвестная)
Текущая команда:  (неизвестная)
Текущая команда:  (неизвестная)

Надо исправить, чтобы все команды строго и четко определялись!

================

Итак, все еще работаем над CommandPath.get_line_and_pos(). Напоминаю, что мы идем постепенно по написанию этой функции, планомерно усложняя ТЗ.
Последняя проблема была в том, что не определялась текущая команда.

Я понял, в чем была беда. self._dict_name всегда == ''. Мне удалось это исправить. Теперь get_line_and_pos() точно находит имя команды. 

Теперь добавь в неё внутрь ветки

if current_command in reserved_commands:
    # ДОЛЖНО СРАБАТЫВАТЬ ВСЕГДА!!!
    # НЕЗАРЕЗЕРВИРОВАННЫХ КОММАНД НЕ ДОЛЖНО БЫТЬ!!!

Вместо pass находждение полного пути текущей команды, которую мы только что определили (current_command = self._dict_name). То есть надо найти список вида

[str, int, in, str, ...]

================

Отлично. Я только дополнил [::-1], чтобы список cmd_path шел в нужном порядке. 

Что теперь:

Напиши фукнцию в CommandPath, которая будет определять "анатомически то же место" в bracket_map, что и в cmd_path.
Функция должна возвращать кусок джейсона, относящийся к команде.
Например:

code = [
    {"game_field": [0]}
]

bracket_map = [
    [
        "[",
        1,
        1,
        0
    ],
    [
        "{",
        2,
        2,
        4
    ],
    [
        "\"game_field\"",
        2,
        2,
        5
    ],
    [
        ":",
        2,
        2,
        17
    ],
    [
        "[",
        3,
        2,
        19
    ],
    [
        "0",
        3,
        2,
        20
    ],
    [
        "]",
        3,
        2,
        21
    ],
    [
        "}",
        2,
        2,
        22
    ],
    [
        "]",
        1,
        3,
        0
    ]
]

Нужный нам кусок, привязанный к cmd_path == [0, 'game_field']

[
    "\"game_field\"",
    2,
    2,
    5
]

================

Поправь функцию find_command_element(), чтобы она находила не ПЕРВОЕ упоминание текущей команды, а НУЖНОЕ. Например, для кода

[
    {"include": {"include": "..."}}
]

bracke_map = [
    [
        "[",
        1,
        1,
        0
    ],
    [
        "{",
        2,
        2,
        4
    ],
    [
        "\"include\"",
        2,
        2,
        5
    ],
    [
        ":",
        2,
        2,
        14
    ],
    [
        "{",
        3,
        2,
        16
    ],
    [
        "\"include\"",
        3,
        2,
        17
    ],
    [
        ":",
        3,
        2,
        26
    ],
    [
        "\"...\"",
        3,
        2,
        28
    ],
    [
        "}",
        3,
        2,
        33
    ],
    [
        "}",
        2,
        2,
        34
    ],
    [
        "]",
        1,
        3,
        0
    ]
]

И вторая ошибка инклюда должна подтянуть (вернуть) именно

[
    "\"include\"",
    3,
    2,
    17
]

а не

[
    "\"include\"",
    2,
    2,
    5
]

================

Нет, сделать просто level = len(cmd_path) НЕДОСТАТОЧНО!

Ведь, если есть include с cmd_path = [1] и с cmd_path = [2] их длина == 1 у обоих. Хотя указывают они на разные инклюды.

Нужно более точная функция, которая будет находить именно ту команду, которая указана в cmd_path.

Например, если cmd_path = [3, 'include', ...] нужно достучаться до команды по координатам влоэженности "3я позиция в общем глобальном списке, заходим в словарь, ищем единственный инклюд (и продолжаем по принципу)"

Уточни команду find_command_element() с этими правками. Если надо, создай вспомогательную функцию-мини_утилиту

================

Перепиши find_command_element() по следующему алгу:

1.Принимает на вход cmd_path, bracket_map.
2.Читает cmd_path в цикле for 
3.Если int, найти в bracket_map первую ближайшую '[', и отсчитать от неё <int> элементов в bracket_map, вернуть <int>-тый
4.Если str, найти ближайшую '{', перепрыгнуть следующий элемент в bracket_map, являющийся строкой-ключем словаря, и следующий после него = ':'. Вернуть следующий - начало значения словаря

если какой-то из этих элементов не находится, вернуть None

================

Учти, что, если мы наткнулись на '{', надо её перепрыгнуть В ЛЮБОМ случае!